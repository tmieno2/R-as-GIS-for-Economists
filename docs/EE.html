<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 6 Extraction Speed Considerations | R as GIS for Economists</title>
<meta name="author" content="Taro Mieno">
<meta name="description" content="Before you start In this chapter, we learn how to parallelize raster data extraction for polygons data. We do not cover parallelization of raster data extraction for points data because it is very...">
<meta name="generator" content="bookdown 0.27 with bs4_book()">
<meta property="og:title" content="Chapter 6 Extraction Speed Considerations | R as GIS for Economists">
<meta property="og:type" content="book">
<meta property="og:description" content="Before you start In this chapter, we learn how to parallelize raster data extraction for polygons data. We do not cover parallelization of raster data extraction for points data because it is very...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 6 Extraction Speed Considerations | R as GIS for Economists">
<meta name="twitter:description" content="Before you start In this chapter, we learn how to parallelize raster data extraction for polygons data. We do not cover parallelization of raster data extraction for points data because it is very...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/_Lato-0.4.1/font.css" rel="stylesheet">
<link href="libs/_Roboto%20Mono-0.4.1/font.css" rel="stylesheet">
<link href="libs/_Montserrat-0.4.1/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<script src="libs/htmlwidgets-1.5.4/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.1.1/leaflet.js"></script><script src="libs/leaflet-providers-1.9.0/leaflet-providers_1.9.0.js"></script><script src="libs/leaflet-providers-plugin-2.1.1/leaflet-providers-plugin.js"></script><link href="libs/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet">
<script src="libs/datatables-binding-0.23/datatables.js"></script><link href="libs/dt-core-1.11.3/css/jquery.dataTables.min.css" rel="stylesheet">
<link href="libs/dt-core-1.11.3/css/jquery.dataTables.extra.css" rel="stylesheet">
<script src="libs/dt-core-1.11.3/js/jquery.dataTables.min.js"></script><link href="libs/crosstalk-1.2.0/css/crosstalk.min.css" rel="stylesheet">
<script src="libs/crosstalk-1.2.0/js/crosstalk.min.js"></script><link href="style.css" rel="stylesheet" type="text/css">
<!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-59758608-3"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag('js', new Date());

      gtag('config', 'UA-59758608-3');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">R as GIS for Economists</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li class="book-part">Demonstration</li>
<li><a class="" href="demo.html"><span class="header-section-number">1</span> R as GIS: Demonstrations</a></li>
<li class="book-part">Foundations</li>
<li><a class="" href="vector-basics.html"><span class="header-section-number">2</span> Vector Data Handling with sf</a></li>
<li><a class="" href="int-vv.html"><span class="header-section-number">3</span> Spatial Interactions of Vector Data: Subsetting and Joining</a></li>
<li><a class="" href="raster-basics.html"><span class="header-section-number">4</span> Raster Data Handling</a></li>
<li><a class="" href="int-RV.html"><span class="header-section-number">5</span> Spatial Interactions of Vector and Raster Data</a></li>
<li class="book-part">(slightly) Advanced Topics</li>
<li><a class="active" href="EE.html"><span class="header-section-number">6</span> Extraction Speed Considerations</a></li>
<li><a class="" href="stars-basics.html"><span class="header-section-number">7</span> Spatiotemporal Raster Data Handling with stars</a></li>
<li class="book-part">Extensions</li>
<li><a class="" href="create-maps.html"><span class="header-section-number">8</span> Creating Maps using ggplot2</a></li>
<li><a class="" href="download-data.html"><span class="header-section-number">9</span> Download and process spatial datasets from within R</a></li>
<li class="book-part">Appendix</li>
<li><a class="" href="par-comp.html"><span class="header-section-number">A</span> Loop and Parallel Computing</a></li>
<li><a class="" href="ggplot2-minimals.html"><span class="header-section-number">B</span> ggplot2 minimals</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="EE" class="section level1" number="6">
<h1>
<span class="header-section-number">6</span> Extraction Speed Considerations<a class="anchor" aria-label="anchor" href="#EE"><i class="fas fa-link"></i></a>
</h1>
<div id="before-you-start-5" class="section level2 unnumbered">
<h2>Before you start<a class="anchor" aria-label="anchor" href="#before-you-start-5"><i class="fas fa-link"></i></a>
</h2>
<p>In this chapter, we learn how to parallelize raster data extraction for <strong>polygons</strong> data. We do not cover parallelization of raster data extraction for <strong>points</strong> data because it is very fast. Thus, the repeated raster data extractions for points is unlikely to be a bottleneck in your work. We first start with parallelizing data extraction from a single-layer raster data. We then move on to a multi-layer raster data case.</p>
<p>There are different ways of parallelizing the same extraction process. We will discuss several parallelization approaches in terms of their speed and memory footprint. You will learn how to parallelize matters. A naive parallelization can actually increase the time of raster data extraction, while a clever parallelization approach can save you hours or even days (depending on the size of the extraction job, of course).</p>
<p>We will use the <code>future.apply</code> and <code>parallel</code> packages for parallelization. Basic knowledge of parallelization using these packages is assumed. Those who are not familiar with parallelized looping using <code><a href="https://rdrr.io/r/base/lapply.html">lapply()</a></code> and parallelization using <code><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply()</a></code> (Mac and Linux users only) or <code>future_lapply()</code> (including Windows), see Chapter <a href="par-comp.html#par-comp">A</a> first.</p>
<div id="direction-for-replication-5" class="section level3 unnumbered">
<h3>Direction for replication<a class="anchor" aria-label="anchor" href="#direction-for-replication-5"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Datasets</strong></p>
<p>All the datasets that you need to import are available <a href="https://www.dropbox.com/sh/gkprbgp8sg5362f/AABLLEUjsGkelCK2aUxaUI72a?dl=0">here</a>. In this chapter, the path to files is set relative to my own working directory (which is hidden). To run the codes without having to mess with paths to the files, follow these steps:</p>
<ul>
<li>set a folder (any folder) as the working directory using <code><a href="https://rdrr.io/r/base/getwd.html">setwd()</a></code><br>
</li>
<li>create a folder called “Data” inside the folder designated as the working directory (if you have created a “Data” folder previously, skip this step)</li>
<li>download the pertinent datasets from <a href="https://www.dropbox.com/sh/gkprbgp8sg5362f/AABLLEUjsGkelCK2aUxaUI72a?dl=0">here</a>
</li>
<li>place all the files in the downloaded folder in the “Data” folder</li>
</ul>
<p>Warning: the folder includes a series of daily PRISM datasets stored by month for 10 years. They amount to <span class="math inline">\(12.75\)</span> GB of data.</p>
<p><strong>Packages</strong></p>
<p>Run the following code to install or load (if already installed) the <code>pacman</code> package, and then install or load (if already installed) the listed package inside the <code><a href="https://rdrr.io/pkg/pacman/man/p_load.html">pacman::p_load()</a></code> function.</p>
<div class="sourceCode" id="cb539"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="kw"><a href="https://rdrr.io/r/base/library.html">require</a></span><span class="op">(</span><span class="st"><a href="https://github.com/trinker/pacman">"pacman"</a></span><span class="op">)</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html">install.packages</a></span><span class="op">(</span><span class="st">"pacman"</span><span class="op">)</span></span>
<span><span class="fu">pacman</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/pacman/man/p_load.html">p_load</a></span><span class="op">(</span></span>
<span>  <span class="va">parallel</span>, <span class="co"># for parallelization</span></span>
<span>  <span class="va">future.apply</span>, <span class="co"># for parallelization</span></span>
<span>  <span class="va">terra</span>, <span class="co"># handle raster data</span></span>
<span>  <span class="va">raster</span>, <span class="co"># handle raster data</span></span>
<span>  <span class="va">exactextractr</span>, <span class="co"># fast extractions</span></span>
<span>  <span class="va">sf</span>, <span class="co"># vector data operations</span></span>
<span>  <span class="va">dplyr</span>, <span class="co"># data wrangling</span></span>
<span>  <span class="va">data.table</span>, <span class="co"># data wrangling</span></span>
<span>  <span class="va">prism</span> <span class="co"># download PRISM data</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div id="single-raster-layer" class="section level2" number="6.1">
<h2>
<span class="header-section-number">6.1</span> Single raster layer<a class="anchor" aria-label="anchor" href="#single-raster-layer"><i class="fas fa-link"></i></a>
</h2>
<p>Let’s prepare for parallel processing for the rest of the section.</p>
<div class="sourceCode" id="cb540"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">parallel</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#--- get the number of logical cores to use ---#</span></span>
<span><span class="op">(</span></span>
<span>  <span class="va">num_cores</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html">detectCores</a></span><span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>[1] 19</code></pre>
<div id="datasets" class="section level3" number="6.1.1">
<h3>
<span class="header-section-number">6.1.1</span> Datasets<a class="anchor" aria-label="anchor" href="#datasets"><i class="fas fa-link"></i></a>
</h3>
<p>We will use the following datasets:</p>
<ul>
<li>
<strong>raster</strong>: Iowa Cropland Data Layer (CDL) data in 2015<br>
</li>
<li>
<strong>polygons</strong>: Regular polygon grids over Iowa</li>
</ul>
<p><strong>Iowa CDL data in 2015</strong></p>
<div class="sourceCode" id="cb542"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#--- Iowa CDL in 2015 ---#</span></span>
<span><span class="op">(</span></span>
<span>  <span class="va">IA_cdl_15</span> <span class="op">&lt;-</span> <span class="fu">rast</span><span class="op">(</span><span class="st">"Data/IA_cdl_2015.tif"</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>class       : SpatRaster 
dimensions  : 11671, 17795, 1  (nrow, ncol, nlyr)
resolution  : 30, 30  (x, y)
extent      : -52095, 481755, 1938165, 2288295  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs 
source      : IA_cdl_2015.tif 
color table : 1 
name        : IA_cdl_2015 
min value   :           0 
max value   :         229 </code></pre>
<p>Values recorded in the raster data are integers representing land use type.</p>
<p><strong>Regularly-sized grids over Iowa</strong></p>
<div class="sourceCode" id="cb544"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#--- regular grids over Iowa ---#</span></span>
<span><span class="op">(</span></span>
<span>  <span class="va">IA_grids</span> <span class="op">&lt;-</span></span>
<span>    <span class="fu">tigris</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tigris/man/counties.html">counties</a></span><span class="op">(</span>state <span class="op">=</span> <span class="st">"IA"</span>, cb <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- create regularly-sized grids ---#</span></span>
<span>    <span class="fu">st_make_grid</span><span class="op">(</span>n <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">50</span>, <span class="fl">50</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- project to the CRS of the CDL data ---#</span></span>
<span>    <span class="fu">st_transform</span><span class="op">(</span><span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/crs.html">crs</a></span><span class="op">(</span><span class="va">IA_cdl_15</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>Geometry set for 2500 features 
Geometry type: POLYGON
Dimension:     XY
Bounding box:  xmin: -53758.56 ymin: 1929065 xmax: 492975.7 ymax: 2293208
Projected CRS: SOURCECRS
First 5 geometries:</code></pre>
<p>Here is how they look (Figure <a href="EE.html#fig:land-grids">6.1</a>):</p>
<div class="sourceCode" id="cb546"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">tm_shape</span><span class="op">(</span><span class="va">IA_cdl_15</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">tm_raster</span><span class="op">(</span>title <span class="op">=</span> <span class="st">"Land Use "</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">tm_shape</span><span class="op">(</span><span class="va">IA_grids</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">tm_polygons</span><span class="op">(</span>alpha <span class="op">=</span> <span class="fl">0</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">tm_layout</span><span class="op">(</span>legend.outside <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:land-grids"></span>
<img src="R_GIS_Book_files/figure-html/land-grids-1.png" alt="Regularly-sized grids and land use type in Iowa in 2105" width="672"><p class="caption">
Figure 6.1: Regularly-sized grids and land use type in Iowa in 2105
</p>
</div>
</div>
<div id="parallelization" class="section level3" number="6.1.2">
<h3>
<span class="header-section-number">6.1.2</span> Parallelization<a class="anchor" aria-label="anchor" href="#parallelization"><i class="fas fa-link"></i></a>
</h3>
<p>Here is how long it takes to extract raster data values for the polygon grids using <code><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract()</a></code>.</p>
<div class="sourceCode" id="cb547"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">tic</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="va">IA_grids</span><span class="op">)</span></span>
<span><span class="fu">toc</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>elapsed 
 26.879 </code></pre>
<hr>
<p>One way to parallelize this process is to let each core work on one polygon at a time. Let’s first define the function to extract values for one polygon and then run it for all the polygons parallelized.</p>
<div class="sourceCode" id="cb549"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#--- function to extract raster values for a single polygon ---#</span></span>
<span><span class="va">get_values_i</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="va">IA_grids</span><span class="op">[</span><span class="va">i</span>, <span class="op">]</span><span class="op">)</span></span>
<span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">temp</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#--- parallelized ---#</span></span>
<span><span class="fu">tic</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">IA_grids</span><span class="op">)</span>, <span class="va">get_values_i</span>, mc.cores <span class="op">=</span> <span class="va">num_cores</span><span class="op">)</span></span>
<span><span class="fu">toc</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>elapsed 
 89.721 </code></pre>
<p>As you can see, this is a terrible way to parallelize the computation process. To see why, let’s look at the computation time of extracting from one polygon, two polygons, and up to five polygons.</p>
<div class="sourceCode" id="cb551"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/joshuaulrich/microbenchmark/">microbenchmark</a></span><span class="op">)</span></span>
<span><span class="va">mb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/microbenchmark/man/microbenchmark.html">microbenchmark</a></span><span class="op">(</span></span>
<span>  <span class="st">"p_1"</span> <span class="op">=</span> <span class="op">{</span></span>
<span>    <span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="va">IA_grids</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  <span class="st">"p_2"</span> <span class="op">=</span> <span class="op">{</span></span>
<span>    <span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="va">IA_grids</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  <span class="st">"p_3"</span> <span class="op">=</span> <span class="op">{</span></span>
<span>    <span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="va">IA_grids</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, <span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  <span class="st">"p_4"</span> <span class="op">=</span> <span class="op">{</span></span>
<span>    <span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="va">IA_grids</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  <span class="st">"p_5"</span> <span class="op">=</span> <span class="op">{</span></span>
<span>    <span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="va">IA_grids</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span>, <span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  times <span class="op">=</span> <span class="fl">100</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb552"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mb</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">data.table</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="va">.</span><span class="op">[</span>, <span class="va">expr</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html">gsub</a></span><span class="op">(</span><span class="st">"p_"</span>, <span class="st">""</span>, <span class="va">expr</span><span class="op">)</span><span class="op">]</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="va">.</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_boxplot</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>y <span class="op">=</span> <span class="va">time</span> <span class="op">/</span> <span class="fl">1e9</span>, x <span class="op">=</span> <span class="va">expr</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ylim</span><span class="op">(</span><span class="fl">0</span>, <span class="cn">NA</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ylab</span><span class="op">(</span><span class="st">"seconds"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">xlab</span><span class="op">(</span><span class="st">"number of polygons to process"</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:comp-polygons"></span>
<img src="R_GIS_Book_files/figure-html/comp-polygons-1.png" alt="Comparison of the computation time of raster data extractions" width="672"><p class="caption">
Figure 6.2: Comparison of the computation time of raster data extractions
</p>
</div>
<p>As you can see in Figure <a href="EE.html#fig:comp-polygons">6.2</a>, there is a significant overhead (about 0.23 seconds) irrespective of the number of the polygons to extract data for. Once the process is initiated and ready to start extracting values for polygons, it does not spend much time processing for additional units of polygon. So, this is a typical example of how you should NOT parallelize. Since each core processes about <span class="math inline">\(136\)</span> polygons, a very simple math suggests that you would spend at least 31.28 (0.23 <span class="math inline">\(\times\)</span> 136) seconds just for preparing extraction jobs.</p>
<hr>
<p>We can minimize this overhead as much as possible by having each core use <code><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract()</a></code> only once in which multiple polygons are processed in the single call. Specifically, we will split the collection of the polygons into 19 groups and have each core extract for one group.</p>
<div class="sourceCode" id="cb553"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#--- number of polygons in a group ---#</span></span>
<span><span class="va">num_in_group</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">floor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">IA_grids</span><span class="op">)</span> <span class="op">/</span> <span class="va">num_cores</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#--- assign group id to polygons ---#</span></span>
<span><span class="va">IA_grids</span> <span class="op">&lt;-</span> <span class="va">IA_grids</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">mutate</span><span class="op">(</span></span>
<span>    <span class="co">#--- create grid id ---#</span></span>
<span>    grid_id <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span>,</span>
<span>    <span class="co">#--- assign group id  ---#</span></span>
<span>    group_id <span class="op">=</span> <span class="va">grid_id</span> <span class="op"><a href="https://rdrr.io/r/base/Arithmetic.html">%/%</a></span> <span class="va">num_in_group</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="fu">tic</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#--- parallelized processing by group ---#</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span></span>
<span>  <span class="fl">1</span><span class="op">:</span><span class="va">num_cores</span>,</span>
<span>  <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">IA_grids</span>, <span class="va">group_id</span> <span class="op">==</span> <span class="va">i</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  mc.cores <span class="op">=</span> <span class="va">num_cores</span></span>
<span><span class="op">)</span></span>
<span><span class="fu">toc</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>elapsed 
 11.901 </code></pre>
<p>Great, this is much better.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;To get the total time, I should include the codes to generate group id. But, they are so quick that I did not time them.&lt;/p&gt;"><sup>81</sup></a></p>
<hr>
<p>Now, we can further reduce the processing time by reducing the size of the object that is returned from each core to be collated into one. In the code above, each core returns a list of <code>data.frame</code>s where each grid of the same group has multiple values from the intersecting raster cells.</p>
<div class="sourceCode" id="cb555"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#--- take a look at the the values extracted for the 1st polygon of the 1st group---#</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">temp</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code>[1] "Error in h(simpleError(msg, call)) : \n  error in evaluating the argument 'y' in selecting a method for function 'exact_extract': no applicable method for 'filter' applied to an object of class \"c('sfc_POLYGON', 'sfc')\"\n"</code></pre>
<div class="sourceCode" id="cb557"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#--- the size of the list of data returned by the first core ---#</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/object.size.html">object.size</a></span><span class="op">(</span><span class="va">temp</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu"><a href="https://rdrr.io/r/base/format.html">format</a></span><span class="op">(</span>units <span class="op">=</span> <span class="st">"GB"</span><span class="op">)</span></span></code></pre></div>
<pre><code>[1] "0 Gb"</code></pre>
<p>In total, about 3GB of data has to be collated into one list from 19 cores. It turns out, this process is costly. To see this, take a look at the following example where the same <code>exact_extrct()</code> processes are run, yet nothing is returned by each core.</p>
<div class="sourceCode" id="cb559"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#--- define the function to extract values by block of polygons ---#</span></span>
<span><span class="va">extract_by_group</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">IA_cdl_15</span>, <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">IA_grids</span>, <span class="va">group_id</span> <span class="op">==</span> <span class="va">i</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co">#--- returns nothing! ---#</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#--- parallelized processing by group ---#</span></span>
<span><span class="fu">tic</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span></span>
<span>  <span class="fl">1</span><span class="op">:</span><span class="va">num_cores</span>,</span>
<span>  <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="fu">extract_by_group</span><span class="op">(</span><span class="va">i</span><span class="op">)</span>,</span>
<span>  mc.cores <span class="op">=</span> <span class="va">num_cores</span></span>
<span><span class="op">)</span></span>
<span><span class="fu">toc</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>elapsed 
  6.689 </code></pre>
<p>Approximately 5.212 seconds were used just to collect the 3GB worth of data from the cores into one.</p>
<p>In most cases, we do not have to carry around all the individual cell values of landuse types for our subsequent analysis. For example, in Demonstration 3 (Chapter <a href="demo.html#demo3">1.3</a>) we just need a summary (count) of each unique landuse type by polygon. So, let’s get the summary before we have the computer collect the objects returned from each core as follows:</p>
<div class="sourceCode" id="cb561"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">extract_by_group_reduced</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">temp_return</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span></span>
<span>    <span class="va">IA_cdl_15</span>,</span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">IA_grids</span>, <span class="va">group_id</span> <span class="op">==</span> <span class="va">i</span><span class="op">)</span></span>
<span>  <span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- combine the list of data.frames into one with polygon id ---#</span></span>
<span>    <span class="fu">rbindlist</span><span class="op">(</span>idcol <span class="op">=</span> <span class="st">"id_within_group"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- find the count of land use type values by polygon ---#</span></span>
<span>    <span class="va">.</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span>num_value <span class="op">=</span> <span class="va">.N</span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">value</span>, <span class="va">id_within_group</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">temp_return</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu">tic</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#--- parallelized processing by group ---#</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span></span>
<span>  <span class="fl">1</span><span class="op">:</span><span class="va">num_cores</span>,</span>
<span>  <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="fu">extract_by_group_reduced</span><span class="op">(</span><span class="va">i</span><span class="op">)</span>,</span>
<span>  mc.cores <span class="op">=</span> <span class="va">num_cores</span></span>
<span><span class="op">)</span></span>
<span><span class="fu">toc</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>elapsed 
  8.514 </code></pre>
<p>It is of course slower than the one that returns nothing, but it is much faster than the one that does not reduce the size before the outcome collation.</p>
<hr>
<p>As you can see, the computation time of the fastest approach is now much less, but you still only gained 81.21. How much time did I spend <strong>writing</strong> the code to do the parallelized group processing? Three minutes. Obviously, what matters to you is the <strong>total</strong> time (coding time plus processing time) you spend to get the desired outcome. Indeed, the time you could save by a clever coding at the most is 89.72 seconds. Writing any kind of code in an attempt to make your code faster takes more time than that. So, don’t even try to make your code faster if the processing time is quite short in the first place. Before you start parallelizing things, go through what you need to go through in terms of coding in your head, and judge if it’s worth it or not.</p>
<p>Imagine processing CDL data for all the states from 2009 to 2020. Then, the whole process will take roughly 15.25 (<span class="math inline">\(51 \times 12 \times 89.721/60/60\)</span>) hours. Again, a super rough calculation tells us that the whole process would be done in 1.45 hours if parallelized in the same way as the best approach we saw above. While 15.25 is still not too terrible (you execute the program before you go to bed, and its results will be available in the afternoon the next day.), it is worth parallelizing this process even taking into account for the time you need to spend to code the parallelization process.</p>
</div>
<div id="summary-1" class="section level3" number="6.1.3">
<h3>
<span class="header-section-number">6.1.3</span> Summary<a class="anchor" aria-label="anchor" href="#summary-1"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li>Do not let each core runs small tasks over and over again (extracting raster values for one polygon at a time), or you will suffer from significant overhead.</li>
<li>Blocking is one way to avoid the problem above.</li>
<li>Reduce the size of the outcome of each core as much as possible to spend less time to simply collating them into one.</li>
<li>Do not forget about the time you would spend on coding parallelized processes.</li>
</ul>
</div>
</div>
<div id="many-multi-layer" class="section level2" number="6.2">
<h2>
<span class="header-section-number">6.2</span> Many multi-layer raster files<a class="anchor" aria-label="anchor" href="#many-multi-layer"><i class="fas fa-link"></i></a>
</h2>
<p>Here we discuss ways to parallelize the process of extracting values from many of multi-layer raster files.</p>
<div id="datasets-1" class="section level3" number="6.2.1">
<h3>
<span class="header-section-number">6.2.1</span> Datasets<a class="anchor" aria-label="anchor" href="#datasets-1"><i class="fas fa-link"></i></a>
</h3>
<p>We will use the following datasets:</p>
<ul>
<li>
<strong>raster</strong>: daily PRISM data 2010 through 2019 stacked by month</li>
<li>
<strong>polygons</strong>: US County polygons</li>
</ul>
<p><strong>daily PRISM precipitation 2010 through 2019</strong></p>
<p>You can download all the prism files from <a href="https://www.dropbox.com/sh/gkprbgp8sg5362f/AABLLEUjsGkelCK2aUxaUI72a?dl=0">here</a>. For those who are interested in learning how to generate the series of daily PRISM data files stored by month, see section <a href="download-data.html#download-prism">9.3</a> for the code.</p>
<p><strong>US counties</strong></p>
<div class="sourceCode" id="cb563"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span></span>
<span>  <span class="va">US_county</span> <span class="op">&lt;-</span> <span class="fu">st_as_sf</span><span class="op">(</span><span class="fu">map</span><span class="op">(</span>database <span class="op">=</span> <span class="st">"county"</span>, plot <span class="op">=</span> <span class="cn">FALSE</span>, fill <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- get state name from ID  ---#</span></span>
<span>    <span class="fu">mutate</span><span class="op">(</span>state <span class="op">=</span> <span class="fu">str_split</span><span class="op">(</span><span class="va">ID</span>, <span class="st">","</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">.</span>, <span class="va">`[[`</span>, <span class="fl">1</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- project to the CRS of the CDL data ---#</span></span>
<span>    <span class="fu">st_transform</span><span class="op">(</span><span class="fu">projection</span><span class="op">(</span><span class="fu">brick</span><span class="op">(</span><span class="st">"Data/PRISM/PRISM_ppt_y2017_m7.tif"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>Simple feature collection with 3076 features and 2 fields
Geometry type: MULTIPOLYGON
Dimension:     XY
Bounding box:  xmin: -124.6813 ymin: 25.12993 xmax: -67.00742 ymax: 49.38323
CRS:           +proj=longlat +datum=NAD83 +no_defs
First 10 features:
                 ID                           geom   state
1   alabama,autauga MULTIPOLYGON (((-86.50517 3... alabama
2   alabama,baldwin MULTIPOLYGON (((-87.93757 3... alabama
3   alabama,barbour MULTIPOLYGON (((-85.42801 3... alabama
4      alabama,bibb MULTIPOLYGON (((-87.02083 3... alabama
5    alabama,blount MULTIPOLYGON (((-86.9578 33... alabama
6   alabama,bullock MULTIPOLYGON (((-85.66866 3... alabama
7    alabama,butler MULTIPOLYGON (((-86.8604 31... alabama
8   alabama,calhoun MULTIPOLYGON (((-85.74313 3... alabama
9  alabama,chambers MULTIPOLYGON (((-85.59416 3... alabama
10 alabama,cherokee MULTIPOLYGON (((-85.46812 3... alabama</code></pre>
</div>
<div id="non-par-ext-multi" class="section level3" number="6.2.2">
<h3>
<span class="header-section-number">6.2.2</span> Non-parallelized extraction<a class="anchor" aria-label="anchor" href="#non-par-ext-multi"><i class="fas fa-link"></i></a>
</h3>
<p>We have already learned in Chapter <a href="int-RV.html#extract-speed">5.3</a> that extracting values from stacked raster layers is faster than doing so from multiple single-layer raster datasets one at a time. Here, daily precipitation datasets are stacked by year-month and saved as multi-layer GeoTIFF files. For example, <strong>PRISM_ppt_y2009_m1.tif</strong> stores the daily precipitation data for January, 2009. This is how long it takes to extract values for US counties from a month’s of daily PRISM precipitation data.</p>
<div class="sourceCode" id="cb565"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">tic</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/stack.html">stack</a></span><span class="op">(</span><span class="st">"Data/PRISM/PRISM_ppt_y2009_m1.tif"</span><span class="op">)</span>, <span class="va">US_county</span>, progress <span class="op">=</span> <span class="cn">F</span><span class="op">)</span></span>
<span><span class="fu">toc</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>elapsed 
 26.571 </code></pre>
<p>Now, to process all the precipitation data from 2009-2018, we consider two approaches in this section are:</p>
<ol style="list-style-type: decimal">
<li>parallelize over polygons (blocked) and do regular loop over year-month</li>
<li>parallelize over year-month</li>
</ol>
</div>
<div id="approach-1-parallelize-over-polygons-and-do-regular-loop-over-year-month" class="section level3" number="6.2.3">
<h3>
<span class="header-section-number">6.2.3</span> Approach 1: parallelize over polygons and do regular loop over year-month<a class="anchor" aria-label="anchor" href="#approach-1-parallelize-over-polygons-and-do-regular-loop-over-year-month"><i class="fas fa-link"></i></a>
</h3>
<p>For this approach, let’s measure the time spent on processing one year-month PRISM dataset and then guess how long it would take to process 120 year-month PRISM datasets.</p>
<div class="sourceCode" id="cb567"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#--- number of polygons in a group ---#</span></span>
<span><span class="va">num_in_group</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">floor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">US_county</span><span class="op">)</span> <span class="op">/</span> <span class="va">num_cores</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#--- define group id ---#</span></span>
<span><span class="va">US_county</span> <span class="op">&lt;-</span> <span class="va">US_county</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">mutate</span><span class="op">(</span></span>
<span>    <span class="co">#--- create grid id ---#</span></span>
<span>    poly_id <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span>,</span>
<span>    <span class="co">#--- assign group id  ---#</span></span>
<span>    group_id <span class="op">=</span> <span class="va">poly_id</span> <span class="op"><a href="https://rdrr.io/r/base/Arithmetic.html">%/%</a></span> <span class="va">num_in_group</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="va">extract_by_group</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">temp_return</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/stack.html">stack</a></span><span class="op">(</span><span class="st">"Data/PRISM/PRISM_ppt_y2009_m1.tif"</span><span class="op">)</span>,</span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">US_county</span>, <span class="va">group_id</span> <span class="op">==</span> <span class="va">i</span><span class="op">)</span></span>
<span>  <span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- combine the list of data.frames into one with polygon id ---#</span></span>
<span>    <span class="fu">rbindlist</span><span class="op">(</span>idcol <span class="op">=</span> <span class="st">"id_within_group"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- find the count of land use type values by polygon ---#</span></span>
<span>    <span class="fu">melt</span><span class="op">(</span>id.var <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"id_within_group"</span>, <span class="st">"coverage_fraction"</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="va">.</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">value</span> <span class="op">*</span> <span class="va">coverage_fraction</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">coverage_fraction</span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">id_within_group</span>, <span class="va">variable</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">temp_return</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu">tic</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">num_cores</span>, <span class="va">extract_by_group</span>, mc.cores <span class="op">=</span> <span class="va">num_cores</span><span class="op">)</span></span>
<span><span class="fu">toc</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>elapsed 
 83.694 </code></pre>
<p>Okay, so this approach does not really help. If we are to process 10 years of daily PRISM data, then it would take roughly 167.39 minutes.</p>
</div>
<div id="approach-2-parallelize-over-the-temporal-dimension-year-month" class="section level3" number="6.2.4">
<h3>
<span class="header-section-number">6.2.4</span> Approach 2: parallelize over the temporal dimension (year-month)<a class="anchor" aria-label="anchor" href="#approach-2-parallelize-over-the-temporal-dimension-year-month"><i class="fas fa-link"></i></a>
</h3>
<p>Instead of parallelize over polygons, let’s parallelize over time (year-month). To do so, we first create a <code>data.frame</code> that has all the year-month combinations we will work on.</p>
<div class="sourceCode" id="cb569"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span></span>
<span>  <span class="va">month_year_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/expand.grid.html">expand.grid</a></span><span class="op">(</span>month <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">12</span>, year <span class="op">=</span> <span class="fl">2009</span><span class="op">:</span><span class="fl">2018</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="fu">data.table</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The following function extract data from a single year-month case:</p>
<div class="sourceCode" id="cb570"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">get_prism_by_month</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span>, <span class="va">vector</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">temp_month</span> <span class="op">&lt;-</span> <span class="va">month_year_data</span><span class="op">[</span><span class="va">i</span>, <span class="va">month</span><span class="op">]</span> <span class="co"># month to work on</span></span>
<span>  <span class="va">temp_year</span> <span class="op">&lt;-</span> <span class="va">month_year_data</span><span class="op">[</span><span class="va">i</span>, <span class="va">year</span><span class="op">]</span> <span class="co"># year to work on</span></span>
<span></span>
<span>  <span class="co">#--- import raster data ---#</span></span>
<span>  <span class="va">temp_raster</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/stack.html">stack</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"Data/PRISM/PRISM_ppt_y"</span>, <span class="va">temp_year</span>, <span class="st">"_m"</span>, <span class="va">temp_month</span>, <span class="st">".tif"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exact_extract</a></span><span class="op">(</span><span class="va">temp_raster</span>, <span class="va">vector</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- combine the extraction results into one data.frame ---#</span></span>
<span>    <span class="fu">rbindlist</span><span class="op">(</span>idcol <span class="op">=</span> <span class="st">"row_id"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- wide to long ---#</span></span>
<span>    <span class="fu">melt</span><span class="op">(</span>id.var <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"row_id"</span>, <span class="st">"coverage_fraction"</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="co">#--- find coverage-weighted average ---#</span></span>
<span>    <span class="va">.</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">value</span> <span class="op">*</span> <span class="va">coverage_fraction</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">coverage_fraction</span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">row_id</span>, <span class="va">variable</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">temp</span><span class="op">)</span></span>
<span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/gc.html">gc</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We then loop over the rows of <code>month_year_data</code> in parallel.</p>
<div class="sourceCode" id="cb571"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">tic</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">month_year_data</span><span class="op">)</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu">get_prism_by_month</span><span class="op">(</span><span class="va">x</span>, <span class="va">US_county</span><span class="op">)</span>, mc.cores <span class="op">=</span> <span class="va">num_cores</span><span class="op">)</span></span>
<span><span class="fu">toc</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>elapsed 
451.477 </code></pre>
<p>It took 7.52 minutes. So, Approach 2 is the clear winner.</p>
</div>
<div id="memory-consideration" class="section level3" number="6.2.5">
<h3>
<span class="header-section-number">6.2.5</span> Memory consideration<a class="anchor" aria-label="anchor" href="#memory-consideration"><i class="fas fa-link"></i></a>
</h3>
<p>So far, we have paid no attention to the memory footprint of the parallelized processes. But, it is crucial when parallelizing many large datasets. Approaches 1 and 2 differ substantially in their memory footprints.</p>
<p>Approach 1 divides the polygons into a group of polygons and parallelizes over the groups when extracting raster values. Approach 2 extracts and holds raster values for 19 of the whole U.S. polygons. So, Approach 1 clearly has a lesser memory footprint. Approach 2 used about 40 Gb of the computer’s memory, almost maxing out the 64 Gb RAM memory of my computer (it’s not just R or C++ that are consuming RAM memory at the time). If you do not go over the limit, it is perfectly fine. Approach 2 is definitely a better option for me. However, if I had 32 Gb RAM memory, Approach 2 would have suffered a significant loss in its performance, while Approach 1 would not have. Or, if the raster data had twice as many cells with the same spatial extent, then Approach 2 would have suffered a significant loss in its performance, while Approach 1 would not have.</p>
<p>It is easy to come up with a case where Approach 1 is preferable. For example, suppose you have multiple 10-Gb raster layers and your computer has 16 Gb RAM memory. Then, Approach 2 clearly does not work, and Approach 1 is your only choice, which is better than not parallelizing at all.</p>
<p>In summary, while letting each core process a larger amount of data, you need to be careful not to exceed the RAM memory limit of your computer.</p>
<!-- ```{r by_year, eval = F}
save_tif <- function(y) {
  temp_ml <- terra::rast(stack(paste0("Data/PRISM/PRISM_ppt_y", y, "_m", 1:12, ".tif")))
  writeRaster(temp_ml, paste0("Data/PRISM/PRISM_ppt_y", y, ".tif"), overwrite = T)
}

mclapply(2009:2018, save_tif, mc.cores = 10)

temp_ml <- stack(paste0("Data/PRISM/PRISM_ppt_y2009.tif"))

tic()
temp <- exact_extract(temp_ml, US_county)
toc()
``` -->

</div>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="int-RV.html"><span class="header-section-number">5</span> Spatial Interactions of Vector and Raster Data</a></div>
<div class="next"><a href="stars-basics.html"><span class="header-section-number">7</span> Spatiotemporal Raster Data Handling with stars</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#EE"><span class="header-section-number">6</span> Extraction Speed Considerations</a></li>
<li>
<a class="nav-link" href="#before-you-start-5">Before you start</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#direction-for-replication-5">Direction for replication</a></li></ul>
</li>
<li>
<a class="nav-link" href="#single-raster-layer"><span class="header-section-number">6.1</span> Single raster layer</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#datasets"><span class="header-section-number">6.1.1</span> Datasets</a></li>
<li><a class="nav-link" href="#parallelization"><span class="header-section-number">6.1.2</span> Parallelization</a></li>
<li><a class="nav-link" href="#summary-1"><span class="header-section-number">6.1.3</span> Summary</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#many-multi-layer"><span class="header-section-number">6.2</span> Many multi-layer raster files</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#datasets-1"><span class="header-section-number">6.2.1</span> Datasets</a></li>
<li><a class="nav-link" href="#non-par-ext-multi"><span class="header-section-number">6.2.2</span> Non-parallelized extraction</a></li>
<li><a class="nav-link" href="#approach-1-parallelize-over-polygons-and-do-regular-loop-over-year-month"><span class="header-section-number">6.2.3</span> Approach 1: parallelize over polygons and do regular loop over year-month</a></li>
<li><a class="nav-link" href="#approach-2-parallelize-over-the-temporal-dimension-year-month"><span class="header-section-number">6.2.4</span> Approach 2: parallelize over the temporal dimension (year-month)</a></li>
<li><a class="nav-link" href="#memory-consideration"><span class="header-section-number">6.2.5</span> Memory consideration</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>R as GIS for Economists</strong>" was written by Taro Mieno. It was last built on 2023-03-20.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
